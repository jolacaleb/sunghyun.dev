---
title: Serverless OAuth2 Server 개발기 - 1
author: Sunghyun Lee
date: 2019-09-29 22:06:01
---

import BlogImage from '../../components/BlogImage';


> 해당 포스트는 [MyMusicTaste tech blog](https://mymusictaste.github.io) 에서 가져온 글로
> 말의 톤 & 매너가 현재 블로그에서 사용하는 톤과 조금 다를 수 있습니다.


안녕하세요. MyMusicTaste Engineering Division에서 백엔드 개발자로 근무하고 있는 이성현이라고 합니다.

이번에 저희 회사에서 필요에 의해 여러 어플리케이션을 운영해야 할 일이 발생하였고, 각 어플리케이션에서 저희 MyMusicTaste의 회원 정보를 이용하여 로그인할 수 있도록 하는 니즈가 발생함에 따라 개발에 착수하게 되었습니다.

본 포스트는 OAuth2 서버를 개발하면서 알게 된 지식들, 그리고 테크닉을 공유하고자 합니다.

## Specification

일단 개발 완료 후 스펙은 다음과 같습니다.

- Language: Python 3.6, JavaScript
- Framework: AWS Lambda Proxy with AWS API Gateway, React 16.9.0
- Database: AWS DynamoDB

본 포스트에서는 독자가 AWS Lambda에 대한 기본적인 지식 및 Python (boto3) 에 대한 기본적인 지식을 가지고 있음을 가정하여 작성되었습니다.

## Before Development ...

현재 MyMusicTaste의 백엔드 서버는 Microservice Architecture (MSA) 로 구성되어 있으며, 각 서비스마다 모두에게 열려있는 **public** API, 그리고 서비스들끼리만 통신이 가능한 **private** API로 나뉘어져 있습니다. 물론 로그인할 때 사용하는 API는 public facing으로 열려있습니다.

그렇다면 여기서 첫번째로 의문이 들었습니다.

#### 단순히 우리 메인 서비스의 login API를 사용하여 JWT를 발급받아 SSO를 구현할 수 있지 않을까? - 그렇다면, OAuth2를 구현할 필요도 없지 않나?

그렇죠. 어차피 해결하고자 하는 이슈가 "다른 어플리케이션에 우리 유저 정보를 제공한다" 라는 것이라면, 굳이 먼 길을 돌아 OAuth2 서버를 개발할 필요도 없을 것입니다. 로그인 API는 열려있기 때문에 누구나 아이디와 패스워드를 이용한 요청으로 로그인을 하면 JWT이 발급되고, 이 JWT를 사용하여 유저 정보를 가져올 수 있을테니까요. 좋은 예시로 구글이 있습니다. 구글 하나의 계정을 가지고 모든 구글에서 제공하는 어플리케이션을 이용할 수 있지요.

<BlogImage src="posts/oauth2-server-1/google_example.png" alt="One account, all of Google" />

하지만 저희는 이 방법을 사용할 수 없었습니다.

이 방법을 사용할 수 없던 이유는 몇 가지가 있었습니다.

1. 외부 어플리케이션은 VPC 내부에 위치하지 않음.
    - 저희는 API Gateway로 [Kong](https://konghq.com/kong)을 사용하고 있으며, JWT도 Kong이 제공하는 JWT Plugin을 통해 발급받은 재료들로 굽고 있습니다. 그러므로, JWT가 적법한 token인지 verify하는 과정에서 Kong에 요청을 하여 key를 가져와야 하는데, 문제는 이 Kong이 당연하게 VPC 내부에 있습니다. 하지만, 외부 어플리케이션의 서버는 VPC 내부에 위치하지 않게 될 것이며, 따라서 Kong에 직접적으로 access할 수가 없습니다.
    - 굳이 해결하자면, Kong의 admin port를 외부에서 access 가능하도록 오픈하던가, 인증을 담당하는 서비스에서 JWT verify를 하는 API를 추가로 만드는 방법이 있긴 합니다. 하지만 전자는 보안 이슈때문에 어렵고, 후자는 인증을 담당하는 서비스에 트래픽이 몰릴 경우 저희 메인 사이트가 좀 더 늘어난 로드를 처리해줘야 합니다.

2. 각 외부 어플리케이션에 모든 유저 정보를 제공하지 않아야 함.
    - 현재 저희 메인 사이트에서 사용하고 있는 유저 정보를 제공하는 API에서는 유저의 필요한 모든 정보를 제공합니다. 물론 비밀번호와 같이 sensitive한 정보는 제외하지만 당연히 유저 정보는 저희 메인 사이트에서 필요한 것만 가지고 있도록 설계되어 있으며, 그것만 넘겨주고 있습니다.
    - 다만 새롭게 개발될 외부 어플리케이션은 그 모든 정보를 필요로 하지 않습니다. 필요한 정보는 정해져 있으며, 그 필요한 정보만 넘겨줄 수 있도록 하는 것이 정의된 스펙이었습니다.

3. 새롭게 제작될 외부 어플리케이션은 높은 확률로 저희의 본 도메인인 mymusictaste.com을 사용하지 않을 것.
    - 사실상 저희의 도메인 (mymusictaste.com)을 사용하지 않는 어플리케이션에 저희의 유저 정보를 유저의 동의 없이 제공하는 것은 전 세계적으로 영향을 끼치고 있는 GDPR에도 위배될 가능성이 있기 때문에 이 또한 고려해야 했습니다. 그러므로 유저의 동의를 받는 process가 따로 필요했습니다.

이 모두를 해결하면서 OAuth2 서버가 없이 구현하는 것은 각각의 서비스에 많은 수정을 거쳐야 했으며, 결론적으로 OAuth2 서버를 구현하는 것이 추후 유지 보수 및 확장성을 살펴보았을 때 더 나은 디시전이라는 결론을 내리게 되었습니다.

## OAuth2?

### Introduction

OAuth는 인증 스킴을 공유하는 여러 방법 중 하나입니다. 하나의 resource로 인증이 가능하다면, 이 인증에 사용되는 resource를 이용하여 다른 서비스에서도 인증이 가능하도록 하는 방법인 셈이죠. 개방형 표준의 특징을 가지고 있으며, 현재 많은 기업들에서 사용하고 있습니다.

OAuth2는 특정 서비스에서 사용되는 유저의 정보를 사실상 세상에 오픈하는 것입니다. 다만, 매우 강화된 보안을 제공해야 하고 특정 scope에 한해서 제공하는 부분을 개발해야 합니다. - 이 말은 OAuth2를 사용하고자 하는 클라이언트가 등록할 때, 유저의 어떤 어떤 정보를 가져가고 싶다고 미리 유저 정보를 보내줄 서버에 이야기를 해놓는 걸로 보시면 됩니다. 

또한 OAuth는 사용자를 `인증`하는 인증 프로토콜(authentication protocol)의 개념이 아닌, `인가`의 개념인 인가 프로토콜(authorization protocol)입니다. 이말은 즉, B 라는 어플리케이션에서 A 라는 어플리케이션의 OAuth를 사용할 수 있도록 설계되었다면, B에서 기본적인 ID, 비밀번호로 로그인을 시도하는 방식이 아니라, A 어플리케이션에서 로그인을 수행하며, A 어플리케이션에서 자원 소유자인 유저에게 "B라는 어플리케이션에서 당신의 정보를 요청하고 있는데 제공해도 될까?" 라고 묻고 이에 대한 인가를 받는 형식이 됩니다.

### Roles

내가 지금 개발해야 하는 것이 어떤 것인지 정의하기 위해 먼저 OAuth2의 역할을 아는 것이 중요합니다. OAuth2를 개발하기 위해 정해진 역할 (Role)이 있으며, 현재 구현되어 있는 것은 무엇인지, 또한 구현해야 하는 것은 무엇인지 파악해야 합니다.

example로 나온 column은 제가 만약 페이스북 OAuth2를 사용하는 앱을 구현하고 있다면 각 Role에 해당하는 객체는 무엇인지 나타내보았습니다.

| name                             | description                                                                                                                                                                       | example (facebook)          |
|----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|
| 자원 소유자 (Resource owner)     | 자신의 계정이 자원 서버에 있는 객체,  보통 유저를 지칭하며,  user-agent (브라우저)를 지칭할 때도 있음. 자신의 계정을 클라이언트에서 사용이  가능하도록 인가(authorize)해 줄 객체. | 유저                        |
| 자원 서버 (Resource server)      | 자원 소유자들의 계정을 가지고 있는 서버.                                                                                                                                          | Facebook (graph API server) |
| 클라이언트 (Client)              | 자원 소유자를 대신하여 자원 서버  혹은 인가 서버에 적절한 자원을 요청하는 객체. 일반적으로 유저의 데이터를 받아서 사용할 어플리케이션.                                            | 내가 만들고 있는 앱         |
| 인가 서버 (Authorization server) | 클라이언트가 자신의 자원을 받아서 사용하도록 하기 위해  token (OAuth2에서 일반적으로 access token)을 발행해 주는 서버.                                                            | Facebook (OAuth2 server)    |

보통 OAuth2를 개발한다고 할 때 개발자가 개발해야 하는 부분은 인가 서버일 것입니다. 

### Basic Flow

OAuth2의 기본적인 흐름은 아래 그림과 같습니다.

<BlogImage src="posts/oauth2-server-1/simple_oauth2_flow.png" alt="OAuth2 Basic Flow" size="full"/>

[RFC6749 #section1.2](https://tools.ietf.org/html/rfc6749#section-1.2)

OAuth2의 인가 방식에는 여러 가지가 있지만, 전체적으로 큰 틀은 위의 그림을 따릅니다.

클라이언트가 먼저 자원 소유자, 즉 유저에게 "당신의 정보를 이용할 건데 괜찮은가?" 라고 묻게 됩니다. 
유저가 어떤 방식으로든 이를 승인하게 되면, 인가 서버에서 `access token`을 획득할 수 있게 되고, 이 `access token`을 통해 
클라이언트는 자신이 원하는 정보 - 클라이언트 측의 어플리케이션을 구동하기 위한, 자원 서버가 가지고 있는 특정 데이터 - 를 성공적으로 받아올 수 있게 됩니다.

기본적인 흐름은 간단합니다.
클라이언트는 유저에게 "너의 정보를 A라는 사이트에서 전송받아올건데 괜찮지? 너의 이메일 주소, A사이트에서 사용중인 닉네임 등을 받아올거야" 라고 묻는 것이고, 유저가 승인한다면 인가 서버에 자신이 승인받았음을 증명하고 데이터들을 달라고 요청하는 것이죠.

### Authorization Grant Types

OAuth2의 인가 승인 유형은 4가지가 있습니다.

| name                                                                   | description                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 인가 코드 (Authorization Code)                                         | 인가 코드는 클라이언트와 자원 소유자 사이에서 중개자의 역할을 하는 인가 서버를 통하여 얻게 됩니다. 인가 코드를 발급받으면 이 인가 코드를 이용하여 access token을 요청할 수 있습니다. Redirection을 기반으로 하기 때문에 자원 소유자의 user-agent와 클라이언트에서 리디렉션이 허용되어야 하며, 중요한 보안상 이점들을 제공하기 때문에 가장 처음으로 고려할 수 있는 인가 방식입니다.                                                                                             |
| 암시적 승인 (Implicit Grant)                                           | 위의 인가 코드 방식의 조금 단순화된 흐름으로써, 클라이언트가 중간 중개자 없이 인가 서버에서  바로 access_token을 요청하는 방식입니다. 즉, 유저의 동의만 얻으면 바로 access_token이 발급되는 방식입니다. 이는 편리하고 인가 코드 방식에 비해 한번의 round-trip time을 줄여주지만, 자원 소유자인 것처럼 가장하여 access_token을 탈취하게 될 보안상 이슈가 존재합니다. 아래의 문서를 참고하세요. [Impersonate Resource Owner](https://tools.ietf.org/html/rfc6749#section-10.16)  |
| 자원 소유자 암호 자격 승인 (Resource Owner Password Credentials Grant) | 자원 소유자의 자격 증명 (예를 들어, username + password의 조합) 을 통하여 access_token을 얻는 방법입니다. 이는 자원 소유자가 클라이언트를 통해 credentials을 전송하기 때문에 자원 소유자와 클라이언트가 "높은 신뢰 관계"에 있어야 사용 가능합니다. RFC6749의 예시에는, 클라이언트가 기기의 Operation system의 일부이거나, 높은 권한을 가진 어플리케이션 일 때만 사용하라고 강력하게 권장하고 있습니다.                                                                         |
| 클라이언트 자격 승인 (Client Credentials Grant)                        | 클라이언트 자격 증명은 자원 서버로부터 받게 될 특정 데이터들이 클라이언트의 관리 하에 사용될 것이거나,  클라이언트 자체가 자원 소유자일 경우 보통 사용할 수 있습니다.                                                                                                                                                                                                                                                                                                          |

가장 널리 사용되고 보안도 가장 뛰어난 인가 코드 (Authorization Code) 방식으로 구현하는 것을 추천합니다. 저도 또한 그렇게 개발하였고 앞으로 이어질 
포스팅의 내용 또한 인가 코드 방식의 구현을 중심으로 다루게 될 것입니다.

### Authorization Code Grant Types Basic Flow

아래의 그림은 기본적인 인가 코드 방식의 흐름도입니다.

<BlogImage src="posts/oauth2-server-1/simple_authorization_code_flow.png" alt="Authorization Code Grant Types Basic Flow" size="full"/>

[RFC6749 #section4/1](https://tools.ietf.org/html/rfc6749#section-4.1)

인가 코드 방식의 각 흐름은 다음과 같습니다.

1. 클라이언트가 유저의 user-agent (보통 browser)를 인가 endpoint로 리디렉트 시킵니다.

2. 유저는 user-agent를 통해 인가 endpoint에서 자원의 접근에 승인합니다. 아래는 우리에게 친숙한 Facebook의 자원 접근 승인을 얻는 방식입니다. 
    <BlogImage src="posts/oauth2-server-1/grant_access_to_resource_owner_information.png" alt="Grant access via user-agent on Facebook" size="half" />
    

3. 유저가 데이터의 접근을 승인했다면, 인가 서버는 처음 클라이언트가 요청한 정보에 포함되어있던 redirection URI로 user-agent를 다시 보냅니다. 이 때, `인증 코드`가 함께 전송됩니다.

4. 클라이언트는 받은 `인증 코드`를 이용하여 인가 서버로 access token을 요청합니다. 요청 시에 클라이언트는 인가 서버와 `인증을 거칩니다.`

5. 인가 서버가 클라이언트를 성공적으로 확인하고 인증하였고, `인증 코드`가 정상적이라고 판단하였다면 access token을 반환합니다.

여기까지가 기본적으로 알고 있어야 할 OAuth2 개발 전 배경 지식입니다. 다음 포스팅에서 본격적으로 Python을 이용한 OAuth2의 개발에 들어가도록 하겠습니다.

[RFC6749](https://tools.ietf.org/html/rfc6749) 하나만 어느 정도 숙지하셔도 OAuth2에 대해서 구현하는데는 문제가 없으실 겁니다. 꼭 한번 읽어보세요!
